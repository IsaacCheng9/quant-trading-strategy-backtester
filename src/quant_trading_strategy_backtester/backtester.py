"""
A backtesting framework for quantitative trading strategies.

It provides a Backtester class that can run a given trading strategy on
historical data and calculate various performance metrics. This framework is
designed to work with the strategy templates defined in a different module in
this repository.
"""

import json
import platform
from datetime import date, datetime

import polars as pl
import streamlit as st

from quant_trading_strategy_backtester.models import Session
from quant_trading_strategy_backtester.models import StrategyModel as StrategyModel
from quant_trading_strategy_backtester.strategies.base import BaseStrategy


def is_running_locally() -> bool:
    """
    Determines if the app is running locally or on Streamlit Cloud by checking
    platform characteristics. platform.processor() returns nothing on Streamlit
    Cloud but returns a value locally.

    Returns:
        bool: True if running locally, False if running on Streamlit Cloud
    """
    return bool(platform.processor())


class Backtester:
    """
    Backtests trading strategies.

    Takes historical data and a trading strategy, runs the strategy on the
    data, and calculates performance metrics.

    Attributes:
        data: Historical price data.
        strategy: The trading strategy to backtest.
        initial_capital: The initial capital for the backtest.
        results: The results of the backtest (initialised after running).
        tickers: The ticker or tickers used in the backtest.
    """

    def __init__(
        self,
        data: pl.DataFrame,
        strategy: BaseStrategy,
        initial_capital: float = 100000.0,
        session=None,
        tickers: str | list[str] | None = None,
    ) -> None:
        self.data = data
        self.strategy = strategy
        self.initial_capital = initial_capital
        self.results: None | pl.DataFrame = None
        self.session = session or Session()
        self.tickers = tickers

    def run(self) -> pl.DataFrame:
        """
        Runs the backtest.

        Generates trading signals using the strategy, calculates returns,
        stores the results, and saves them to the database.

        Returns:
            A DataFrame containing the backtest results.
        """
        signals = self.strategy.generate_signals(self.data)
        self.results = self._calculate_returns(signals)
        self.save_results()
        return self.results

    def _calculate_returns(self, signals: pl.DataFrame) -> pl.DataFrame:
        """
        Calculates returns based on the generated signals.

        Computes asset returns, strategy returns, cumulative returns, and the
        equity curve.

        Args:
            signals: The trading signals generated by the strategy.

        Returns:
            A DataFrame containing calculated returns and related metrics.
        """
        # Ensure 'Date' column is present in signals DataFrame
        if "Date" not in signals.columns:
            raise ValueError("'Date' column is missing from the signals DataFrame")

        # Pairs trading
        if "Close_1" in self.data.columns and "Close_2" in self.data.columns:
            asset_returns = (
                self.data["Close_1"] - self.data["Close_1"].shift(1)
            ) / self.data["Close_1"].shift(1) - (
                self.data["Close_2"] - self.data["Close_2"].shift(1)
            ) / self.data["Close_2"].shift(1)
        # Single asset trading
        elif "Close" in self.data.columns:
            asset_returns = (
                self.data["Close"] - self.data["Close"].shift(1)
            ) / self.data["Close"].shift(1)
        else:
            raise ValueError("Data does not contain required 'Close' columns")

        portfolio = signals.with_columns(
            [
                pl.col("positions"),
                asset_returns.alias("asset_returns"),
                (pl.col("positions").shift(1) * asset_returns).alias(
                    "strategy_returns"
                ),
            ]
        )

        # Handle potential NaN or inf values
        portfolio = portfolio.with_columns(
            [
                pl.col("strategy_returns")
                .replace({float("inf"): None, float("-inf"): None})
                .fill_null(0)
            ]
        )

        portfolio = portfolio.with_columns(
            [
                (1 + pl.col("strategy_returns")).cum_prod().alias("cumulative_returns"),
                (
                    self.initial_capital * (1 + pl.col("strategy_returns")).cum_prod()
                ).alias("equity_curve"),
            ]
        )

        return portfolio

    def get_performance_metrics(self) -> dict[str, float] | None:
        """
        Calculates key performance metrics from the trading strategy backtest.

        Computes the total return, Sharpe ratio, and maximum drawdown based on
        the backtest results.

        Returns:
            A dictionary containing performance metrics, or None if the backtest
            hasn't been run yet.
        """
        if self.results is None:
            return None

        total_return = (
            float(self.results["cumulative_returns"].cast(pl.Float64).tail(1).item())
            - 1
        )

        # Measure the risk-adjusted return, assuming 252 trading days per year.
        returns_mean = float(self.results["strategy_returns"].cast(pl.Float64).mean())  # type: ignore
        returns_std = float(self.results["strategy_returns"].cast(pl.Float64).std())  # type: ignore
        if returns_std != 0:
            sharpe_ratio = float((252**0.5) * returns_mean / returns_std)
        else:
            sharpe_ratio = float("nan")

        # Measure the maximum loss from a peak to a trough of the equity curve.
        drawdowns = (
            self.results["equity_curve"] / self.results["equity_curve"].cum_max() - 1
        )
        max_drawdown = float(drawdowns.cast(pl.Float64).min())  # type: ignore

        return {
            "Total Return": total_return,
            "Sharpe Ratio": sharpe_ratio,
            "Max Drawdown": max_drawdown,
        }

    def save_results(self) -> None:
        """
        Saves the strategy and its backtest results to either the local database
        or session state, depending on the environment.
        """
        metrics = self.get_performance_metrics()
        if metrics is None:
            raise ValueError("Backtest hasn't been run yet. Call run() first.")

        strategy_params = self.strategy.get_parameters()
        strategy_name = self.strategy.__class__.__name__

        # Extract tickers from data columns if not provided
        if self.tickers is None:
            if "Close_1" in self.data.columns and "Close_2" in self.data.columns:
                pass
            else:
                pass

        # Determine start and end dates
        start_date_row = self.data.select(
            pl.col("Date").dt.year().alias("year"),
            pl.col("Date").dt.month().alias("month"),
            pl.col("Date").dt.day().alias("day"),
        ).row(0)
        end_date_row = self.data.select(
            pl.col("Date").dt.year().alias("year"),
            pl.col("Date").dt.month().alias("month"),
            pl.col("Date").dt.day().alias("day"),
        ).row(-1)

        start_date = date(start_date_row[0], start_date_row[1], start_date_row[2])
        end_date = date(end_date_row[0], end_date_row[1], end_date_row[2])

        if is_running_locally():
            try:
                # Check if a strategy with the same name, parameters, and date
                # range already exists
                existing_strategy = (
                    self.session.query(StrategyModel)
                    .filter_by(
                        name=strategy_name,
                        parameters=json.dumps(strategy_params),
                        start_date=start_date,
                        end_date=end_date,
                    )
                    .first()
                )

                if existing_strategy is None:
                    new_strategy = StrategyModel(
                        name=strategy_name,
                        parameters=json.dumps(strategy_params),
                        total_return=metrics["Total Return"],
                        sharpe_ratio=metrics["Sharpe Ratio"],
                        max_drawdown=metrics["Max Drawdown"],
                        tickers=json.dumps(self.tickers),
                        start_date=start_date,
                        end_date=end_date,
                    )
                    self.session.add(new_strategy)
                    self.session.commit()
                    print(f"Strategy {strategy_name} saved successfully.")
                else:
                    print(
                        f"Strategy {strategy_name} with same parameters already exists. Skipping save."
                    )
            except Exception as e:
                self.session.rollback()
                raise ValueError(f"Failed to save strategy results: {str(e)}")
        else:
            # Use Streamlit session state for cloud deployment
            if "strategy_results" not in st.session_state:
                st.session_state.strategy_results = []

            st.session_state.strategy_results.append(
                {
                    "date_created": datetime.now(),
                    "name": strategy_name,
                    "parameters": strategy_params,
                    "total_return": metrics["Total Return"],
                    "sharpe_ratio": metrics["Sharpe Ratio"],
                    "max_drawdown": metrics["Max Drawdown"],
                    "tickers": self.tickers,
                    "start_date": start_date,
                    "end_date": end_date,
                }
            )
            print(f"Strategy {strategy_name} saved to session state.")
