"""
A backtesting framework for quantitative trading strategies.

It provides a Backtester class that can run a given trading strategy on
historical data and calculate various performance metrics. This framework is
designed to work with the strategy templates defined in a different module in
this repository.
"""

import numpy as np
import pandas as pd
from quant_trading_strategy_backtester.strategy_templates import Strategy


class Backtester:
    """
    Backtests trading strategies.

    Takes historical data and a trading strategy, runs the strategy on the
    data, and calculates performance metrics.

    Attributes:
        data: Historical price data.
        strategy: The trading strategy to backtest.
        initial_capital: The initial capital for the backtest.
        results: The results of the backtest (initialized after running).
    """

    def __init__(
        self, data: pd.DataFrame, strategy: Strategy, initial_capital: float = 100000.0
    ) -> None:
        self.data = data
        self.strategy = strategy
        self.initial_capital = initial_capital
        self.results = None

    def run(self) -> pd.DataFrame:
        """
        Runs the backtest.

        Generates trading signals using the strategy, calculates returns,
        and stores the results.

        Returns:
            A DataFrame containing the backtest results.
        """
        signals = self.strategy.generate_signals(self.data)
        self.results = self._calculate_returns(signals)
        return self.results

    def _calculate_returns(self, signals: pd.DataFrame) -> pd.DataFrame:
        """
        Calculates returns based on the generated signals.

        Computes asset returns, strategy returns, cumulative returns, and the
        equity curve.

        Args:
            signals: The trading signals generated by the strategy.

        Returns:
            A DataFrame containing calculated returns and related metrics.
        """
        portfolio = pd.DataFrame(index=signals.index)
        portfolio["positions"] = signals["positions"]

        # Pairs trading
        if "Close_1" in self.data.columns and "Close_2" in self.data.columns:
            portfolio["asset_returns"] = (
                self.data["Close_1"].pct_change() - self.data["Close_2"].pct_change()
            )
        # Single asset trading
        elif "Close" in self.data.columns:
            portfolio["asset_returns"] = self.data["Close"].pct_change()
        else:
            raise ValueError("Data does not contain required 'Close' columns")

        portfolio["strategy_returns"] = (
            portfolio["positions"].shift(1) * portfolio["asset_returns"]
        )
        # Handle potential NaN or inf values
        portfolio["strategy_returns"] = (
            portfolio["strategy_returns"].replace([np.inf, -np.inf], np.nan).fillna(0)
        )
        portfolio["cumulative_returns"] = (1 + portfolio["strategy_returns"]).cumprod()
        portfolio["equity_curve"] = (
            self.initial_capital * portfolio["cumulative_returns"]
        )

        return portfolio

    def get_performance_metrics(self) -> dict[str, float] | None:
        """
        Calculates key performance metrics from the trading strategy backtest.

        Computes the total return, Sharpe ratio, and maximum drawdown based on
        the backtest results.

        Returns:
            A dictionary containing performance metrics, or None if the backtest
            hasn't been run yet.
        """
        if self.results is None:
            return None

        total_return = self.results["cumulative_returns"].iloc[-1] - 1

        # Measure the risk-adjusted return, assuming 252 trading days per year.
        returns_mean = self.results["strategy_returns"].mean()
        returns_std = self.results["strategy_returns"].std()
        if returns_std != 0 and not np.isnan(returns_std):
            sharpe_ratio = np.sqrt(252) * returns_mean / returns_std
        else:
            sharpe_ratio = np.nan

        # Measure the maximum loss from a peak to a trough of the equity curve.
        drawdowns = (
            self.results["equity_curve"] / self.results["equity_curve"].cummax() - 1
        )
        max_drawdown = drawdowns.min()

        return {
            "Total Return": total_return,
            "Sharpe Ratio": sharpe_ratio,
            "Max Drawdown": max_drawdown,
        }
