"""
A backtesting framework for quantitative trading strategies.

It provides a Backtester class that can run a given trading strategy on
historical data and calculate various performance metrics. This framework is
designed to work with the strategy templates defined in a different module in
this repository.
"""

import json
from datetime import date

import polars as pl

from quant_trading_strategy_backtester.models import Session
from quant_trading_strategy_backtester.models import StrategyModel as StrategyModel
from quant_trading_strategy_backtester.strategies.base import BaseStrategy


class Backtester:
    """
    Backtests trading strategies.

    Takes historical data and a trading strategy, runs the strategy on the
    data, and calculates performance metrics.

    Attributes:
        data: Historical price data.
        strategy: The trading strategy to backtest.
        initial_capital: The initial capital for the backtest.
        results: The results of the backtest (initialised after running).
        tickers: The ticker or tickers used in the backtest.
    """

    def __init__(
        self,
        data: pl.DataFrame,
        strategy: BaseStrategy,
        initial_capital: float = 100000.0,
        session=None,
        tickers: str | list[str] | None = None,
    ) -> None:
        self.data = data
        self.strategy = strategy
        self.initial_capital = initial_capital
        self.results: None | pl.DataFrame = None
        self.session = session or Session()
        self.tickers = tickers

    def run(self) -> pl.DataFrame:
        """
        Runs the backtest.

        Generates trading signals using the strategy, calculates returns,
        stores the results, and saves them to the database.

        Returns:
            A DataFrame containing the backtest results.
        """
        signals = self.strategy.generate_signals(self.data)
        self.results = self._calculate_returns(signals)
        self.save_results()
        return self.results

    def _calculate_returns(self, signals: pl.DataFrame) -> pl.DataFrame:
        """
        Calculates returns based on the generated signals.

        Computes asset returns, strategy returns, cumulative returns, and the
        equity curve.

        Args:
            signals: The trading signals generated by the strategy.

        Returns:
            A DataFrame containing calculated returns and related metrics.
        """
        # Ensure 'Date' column is present in signals DataFrame
        if "Date" not in signals.columns:
            raise ValueError("'Date' column is missing from the signals DataFrame")

        # Pairs trading
        if "Close_1" in self.data.columns and "Close_2" in self.data.columns:
            asset_returns = (
                self.data["Close_1"] - self.data["Close_1"].shift(1)
            ) / self.data["Close_1"].shift(1) - (
                self.data["Close_2"] - self.data["Close_2"].shift(1)
            ) / self.data["Close_2"].shift(1)
        # Single asset trading
        elif "Close" in self.data.columns:
            asset_returns = (
                self.data["Close"] - self.data["Close"].shift(1)
            ) / self.data["Close"].shift(1)
        else:
            raise ValueError("Data does not contain required 'Close' columns")

        portfolio = signals.with_columns(
            [
                pl.col("positions"),
                asset_returns.alias("asset_returns"),
                (pl.col("positions").shift(1) * asset_returns).alias(
                    "strategy_returns"
                ),
            ]
        )

        # Handle potential NaN or inf values
        portfolio = portfolio.with_columns(
            [
                pl.col("strategy_returns")
                .replace({float("inf"): None, float("-inf"): None})
                .fill_null(0)
            ]
        )

        portfolio = portfolio.with_columns(
            [
                (1 + pl.col("strategy_returns")).cum_prod().alias("cumulative_returns"),
                (
                    self.initial_capital * (1 + pl.col("strategy_returns")).cum_prod()
                ).alias("equity_curve"),
            ]
        )

        return portfolio

    def get_performance_metrics(self) -> dict[str, float] | None:
        """
        Calculates key performance metrics from the trading strategy backtest.

        Computes the total return, Sharpe ratio, and maximum drawdown based on
        the backtest results.

        Returns:
            A dictionary containing performance metrics, or None if the backtest
            hasn't been run yet.
        """
        if self.results is None:
            return None

        total_return = (
            float(self.results["cumulative_returns"].cast(pl.Float64).tail(1).item())
            - 1
        )

        # Measure the risk-adjusted return, assuming 252 trading days per year.
        returns_mean = float(self.results["strategy_returns"].cast(pl.Float64).mean())  # type: ignore
        returns_std = float(self.results["strategy_returns"].cast(pl.Float64).std())  # type: ignore
        if returns_std != 0:
            sharpe_ratio = float((252**0.5) * returns_mean / returns_std)
        else:
            sharpe_ratio = float("nan")

        # Measure the maximum loss from a peak to a trough of the equity curve.
        drawdowns = (
            self.results["equity_curve"] / self.results["equity_curve"].cum_max() - 1
        )
        max_drawdown = float(drawdowns.cast(pl.Float64).min())  # type: ignore

        return {
            "Total Return": total_return,
            "Sharpe Ratio": sharpe_ratio,
            "Max Drawdown": max_drawdown,
        }

    def save_results(self) -> None:
        """
        Saves the strategy and its backtest results to the database if not already present.
        """
        metrics = self.get_performance_metrics()
        if metrics is None:
            raise ValueError("Backtest hasn't been run yet. Call run() first.")

        strategy_params = self.strategy.get_parameters()
        strategy_name = self.strategy.__class__.__name__

        # Extract tickers from data columns if not provided
        if self.tickers is None:
            if "Close_1" in self.data.columns and "Close_2" in self.data.columns:
                pass
            else:
                pass

        # Determine start and end dates
        start_date_row = self.data.select(
            pl.col("Date").dt.year().alias("year"),
            pl.col("Date").dt.month().alias("month"),
            pl.col("Date").dt.day().alias("day"),
        ).row(0)
        end_date_row = self.data.select(
            pl.col("Date").dt.year().alias("year"),
            pl.col("Date").dt.month().alias("month"),
            pl.col("Date").dt.day().alias("day"),
        ).row(-1)

        start_date = date(start_date_row[0], start_date_row[1], start_date_row[2])
        end_date = date(end_date_row[0], end_date_row[1], end_date_row[2])

        try:
            # Check if a strategy with the same name, parameters, and date
            # range already exists
            existing_strategy = (
                self.session.query(StrategyModel)
                .filter_by(
                    name=strategy_name,
                    parameters=json.dumps(strategy_params),
                    start_date=start_date,
                    end_date=end_date,
                )
                .first()
            )

            if existing_strategy is None:
                new_strategy = StrategyModel(
                    name=strategy_name,
                    parameters=json.dumps(strategy_params),
                    total_return=metrics["Total Return"],
                    sharpe_ratio=metrics["Sharpe Ratio"],
                    max_drawdown=metrics["Max Drawdown"],
                    tickers=json.dumps(self.tickers),
                    start_date=start_date,
                    end_date=end_date,
                )
                self.session.add(new_strategy)
                self.session.commit()
                print(f"Strategy {strategy_name} saved successfully.")
            else:
                print(
                    f"Strategy {strategy_name} with same parameters already exists. Skipping save."
                )
        except Exception as e:
            self.session.rollback()
            raise ValueError(f"Failed to save strategy results: {str(e)}")
